<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>fibonhack | pwn</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/assets/css/bootstrap-3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/css/main.css">


    <link rel="shortcut icon" href="/assets/images/favicon.jpg">
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-167636907-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-167636907-1');
    </script>

</head>


    <body>
      <div class="container">

        <header class="row">
    <div class="col-lg-8 col-lg-offset-2">
        <img class="main-logo" src="/assets/images/fibonhack.png" alt="fibonhack">
    </div>
</header>

<div class="row">
  <div class="col-lg-8 col-lg-offset-2">
    <div class="menu glow-yellow">
      <ul>
          <li><a href="/" >home</a></li>
          <li><a href="/resources" >resources</a></li>
          <li><a href="/posts" >posts</a></li>
          <li><a href="/writeups" >writeups</a></li>
        </ul>
    </div>
  </div>
</div>



        <div class="row">
          <div class="col-lg-8 col-lg-offset-2">
            <main>
            <div class="post">
  <article class="post-content">
  <h1 id="common-pitfalls-in-exploit-development">Common pitfalls in exploit development</h1>
<p>What is this about? Mainly it is about questions like that: <code class="language-plaintext highlighter-rouge">Why my exploit is popping a shell in local but is crashing in remote?</code>. Spoiler the answer most of the time is not <code class="language-plaintext highlighter-rouge">Because some bit got flipped through the journey to the remote server</code>. Dont laugh, this is actually a thing: <a href="https://resources.bishopfox.com/files/slides/2019/Kaspersky%20SAS-Ghost-in-the-Browser-Broad-Scale-Espionage-with-Bitsquatting-10Apr2019-%20Slides.pdf">lol</a>.</p>

<h2 id="how-to-develop-the-exploit-in-local-with-the-sameish-environment">How to: Develop the exploit in local with the same(~ish) environment</h2>

<p>What does that mean? By simplifying a lot: we are going to execute <code class="language-plaintext highlighter-rouge">./chall.</code> with the same <code class="language-plaintext highlighter-rouge">libc.so.6</code> the remote server is using.</p>

<p>What do you need:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">chall</code></li>
  <li><code class="language-plaintext highlighter-rouge">libc.so.6</code>: should be possible to get? <a href="https://book.hacktricks.xyz/exploiting/linux-exploiting-basic-esp/rop-leaking-libc-address">this link should help</a></li>
  <li><code class="language-plaintext highlighter-rouge">ld.so</code>: basically, it is the program responsible to load all the dinamically linkd libraries. Refer to <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man ld.so</a> if you want to know more.</li>
</ul>

<h3 id="method-1-patchelf--ld_preload">Method 1: patchelf + LD_PRELOAD</h3>
<p>We are going to patch the binary in order to change the interpeter path.</p>

<p>How to see the interpeter path? From</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file chall
chall: ELF 64-bit LSB shared object, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>c108eced55038588d5b1a6579bd72b9e0c7fd01b, not stripped
</code></pre></div></div>
<p>-&gt; the intepreter path is /lib64/ld-linux-x86-64.so.2, note this is an absolute path!</p>

<p>How to patch the binary? There are tons of way, you could do it by hand but for the sake of simplicity you can use <a href="https://github.com/NixOS/patchelf">patchelf</a></p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> ./ld.so /tmp/ld.so
<span class="c"># dont put a long filename, using /tmp/something should be good</span>
<span class="c"># assert(len(your_interpreter_path) &lt;= len(chall_interpreter_path))</span>
patchelf <span class="nt">--set-interpreter</span> /tmp/ld.so ./chall <span class="c"># this command patch the binary</span>
</code></pre></div></div>

<ul>
  <li>Then if you want to run from shell do this:
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">LD_PRELOAD</span><span class="o">=</span>./libc.so.6 ./test
</code></pre></div>    </div>
  </li>
  <li>Or if you want to run from your pwntools script do this:
    <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">([</span><span class="s">"./chall"</span><span class="p">],</span> <span class="n">env</span><span class="o">=</span><span class="p">{</span><span class="s">"LD_PRELOAD"</span><span class="p">:</span><span class="s">"/path/to/libc.so"</span><span class="p">})</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="method-2-only-ld_preload">Method 2: only LD_PRELOAD</h3>
<p>Warning: with this method you might not be able to see debug symbols of <code class="language-plaintext highlighter-rouge">chall</code>, so i would not recommend this way if you want to attach to the process and debug it!</p>

<ul>
  <li>From shell:
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">LD_PRELOAD</span><span class="o">=</span>./libc.so.6 ./ld.so ./chall
</code></pre></div>    </div>
  </li>
  <li>From pwntools script:
    <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">([</span><span class="s">"/path/to/ld.so"</span><span class="p">,</span> <span class="s">"./chall"</span><span class="p">],</span> <span class="n">env</span><span class="o">=</span><span class="p">{</span><span class="s">"LD_PRELOAD"</span><span class="p">:</span><span class="s">"/path/to/libc.so"</span><span class="p">})</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="method-x-qemu">Method X: Qemu</h3>
<p>With qemu-user you can emulate any userspace programs written for a different architecture (e.g. ARM, MIPS, …), without emulating an entire operating systems. And you can also debug it.</p>

<p>For example, execute an arm64 program for linux, with a custom libc
<code class="language-plaintext highlighter-rouge">qemu-aarch64 -L &lt;your LD_PREFIX&gt; -E LD_PRELOAD=/path/to/libc.so ./chall</code></p>

<h3 id="method-xxx-docker">Method XXX: Docker</h3>
<p>Using docker enforces isolation of the processes, and it is not required, the methods above work well. If you still want a sandbox environment to mess up with (if you delete the libc in your system, <em>YOU WILL HAVE A REALLY BAD TIME</em>). I suggest using the following alias to use a suitable docker</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
pwndocker<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$# </span><span class="nt">-ne</span> 1 <span class="o">]]</span> <span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"pwndocker &lt;dockername&gt;"</span>
        <span class="k">return </span>1<span class="p">;</span>
    <span class="k">fi
    </span>docker run <span class="nt">-d</span> <span class="nt">-h</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="nt">--name</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="nt">-v</span> <span class="nv">$PWD</span>:/ctf/work <span class="nt">--cap-add</span><span class="o">=</span>SYS_PTRACE <span class="nt">--security-opt</span> <span class="nv">seccomp</span><span class="o">=</span>unconfined skysider/pwndocker
<span class="o">}</span>

</code></pre></div></div>

<h2 id="i-dont-want-to-use-the-remote-libc-but-my-exploit-is-still-working-only-in-local">I don’t want to use the remote libc, but my exploit is still working only in local</h2>
<p>99% of the times, the remote environment has Ubuntu LTS. The libc built for Ubuntu has been built with some flags that are not shared among all linux distros. One of this flags enforces a runtime check: every time you enter a function, the stack has to be aligned at 0x10 bytes (64 bits). If this is not the situation, the program will be killed via <code class="language-plaintext highlighter-rouge">SIGSEGV</code>.</p>

<p>How to solve? If you are in this situation, you are very likely building a ROP. This means that you need to jump to that function only when the stack is properly aligned. How can you align the stack if it is not? Simply ad a NOP gadget (a gadget that includes only a <code class="language-plaintext highlighter-rouge">ret</code> instruction).</p>

<h2 id="how-to-debug-programs-without-losing-your-mental-sanity">How to: Debug programs without losing your mental sanity</h2>

<p>First of all, if the binary is stripped, aka you have no functions names, readd them to the binary so gdb can will be less PITA.</p>

<p>Example of a <code class="language-plaintext highlighter-rouge">chall</code> binary which is stripped</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file chall
chall: ELF 64-bit LSB shared object, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>c108eced55038588d5b1a6579bd72b9e0c7fd01b, stripped &lt;<span class="nt">--</span> this is stripped
</code></pre></div></div>

<p>There are a lot of ways to do so, but i usually use ghidra.</p>

<h3 id="add-symbols-to-any-elf-file-using-ghidra">Add symbols to any elf file using ghidra</h3>

<ul>
  <li>Put those scripts in ~/ghidra_scripts: https://github.com/nick0ve/syms2elf</li>
  <li>In ghidra:
    <ul>
      <li>go to the Script Manager</li>
      <li>search for syms2elf.py</li>
      <li>execute it</li>
    </ul>
  </li>
  <li>chmod +x chall.sym.elf</li>
  <li>./chall.sym.elf</li>
  <li>profit?</li>
</ul>

<p>Note: If you want to export symbols for a PIE executable, you have to modify the base address to 0x0. (Yes I’m too lazy to fix this). To do it goto: Window -&gt; Memory map -&gt; Set Image Base (image of the home). You can go <a href="https://guidedhacking.com/threads/how-to-rebase-a-module-in-ghidra-ida-pro.16511/">there</a> for a graphical walkthrough.
Note: If you don’t know how to reach the script manager, take a look at https://www.shogunlab.com/blog/2019/12/22/here-be-dragons-ghidra-1.html</p>

<h3 id="add-symbols-to-elf-files-other-methods">Add symbols to elf files, other methods</h3>
<p>I’m not gonna explain how to use those scripts, but they could be very useful by time to time, so I’m gonna stick ‘em there.</p>
<ul>
  <li>https://github.com/wapiflapi/wsym</li>
  <li>https://github.com/cesena/ghidra2dwarf</li>
  <li>https://github.com/sciencemanx/dress</li>
</ul>

<h2 id="how-to-run-a-program-with-aslr-disabled">How to: Run a program with ASLR disabled</h2>

<ul>
  <li>
    <p>The don’t ever do it method: <code class="language-plaintext highlighter-rouge">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code> &lt;- this is gonna disable aslr for every process which will be executed after that command, which is something you dont really want.</p>
  </li>
  <li>
    <p>The right method: Run a shell with aslr disabled, and every command that you will execute in that shell will keep aslr disabled: <code class="language-plaintext highlighter-rouge">setarch $(uname -m) -R /bin/bash</code>, or if you want to execute only the challenge binary with no aslr: <code class="language-plaintext highlighter-rouge">setarch $(uname -m) -R /path/to/chall</code></p>
  </li>
</ul>

<h2 id="how-to-attach-to-a-running-process-with-gdb">How to: attach to a running process with gdb</h2>

<p>After running the process, let it wait for your input. For instance if you are developing an exploit with pwntools, and you want to be able to debug it, you would modify your script from this:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
    <span class="n">right_number_of_As</span><span class="p">,</span>
    <span class="n">ropchain</span>
<span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>
<p>to:</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
    <span class="n">right_number_of_As</span><span class="p">,</span>
    <span class="n">ropchain</span>
<span class="p">)</span>
<span class="n">ui</span><span class="p">.</span><span class="n">pause</span><span class="p">()</span> <span class="c1"># from pwn import ui
</span><span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<p>Then open two terminals.</p>

<p>In T1 execute the exploit:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./exp.py LOCAL
</code></pre></div></div>

<p>In T2 attach to the process:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb <span class="nt">-p</span> <span class="si">$(</span>pidof chall<span class="si">)</span> <span class="nt">-ex</span> <span class="s2">"break vulnerable_function"</span> <span class="nt">-ex</span> <span class="s2">"continue"</span>
</code></pre></div></div>

<p>–&gt; Profit.</p>

<h2 id="how-to-avoid-alarm-signal">How to: avoid alarm signal</h2>

<p>In most of the pwn challs, to avoid stuck connections the program will be killed with a <code class="language-plaintext highlighter-rouge">SIGALRM</code> after a small amount of time. Obv, it is recommended to avoid this restriction while you are debugging. Fortunately, gdb can help, not only with <code class="language-plaintext highlighter-rouge">SIGALRM</code> but with most of linux signals.</p>

<p>Attaching to the process with gdb (for example with <code class="language-plaintext highlighter-rouge">gdb -p $(pidof chall)</code> will automatically catch all the <code class="language-plaintext highlighter-rouge">SIGALRM</code> sent to the <code class="language-plaintext highlighter-rouge">chall</code> process and it will not forward them to the child process (by default). Inside gdb you can also stop other signals, for example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>handle SIGWINCH nopass
</code></pre></div></div>

<p>You can also set a catchpoint inside gdb</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catch signal SIGALRM
</code></pre></div></div>

<h1 id="other-tricks-that-you-might-find-useful">Other tricks that you might find useful</h1>

<h3 id="how-to-know-if-my-shellcode-is-being-executed-before-the-crash">How to know if my shellcode is being executed before the crash?</h3>
<p>Put a breakpoint in your shellcode and see if a SIGTRAP is triggered:</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shellcode</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\xcc</span><span class="s">'</span> <span class="o">+</span> <span class="n">shellcode</span>
</code></pre></div></div>
<p>What is 0xcc? It corresponds to the instruction <code class="language-plaintext highlighter-rouge">int3</code>, which is used by all the common OSes to support debugging. When the CPU executes this instruction, an exception of type 3 (TRAP) is generated, the corresponding exception handler is called, and the Linux kernel will notify this exception to the process who generated it with a signal. The default behaviour for a process when a signal of type 3 is received, is to terminate because of SIGTRAP, but if a debugger (gdb in the Linux world) is attached, it will give the control to the user, like when a <code class="language-plaintext highlighter-rouge">sane</code> breakpoint is hit (e.g. the one you put from the gdb cli with the command <code class="language-plaintext highlighter-rouge">b *main</code>). <a href="https://www.programmersought.com/article/55404064361/">More info there</a></p>

<p>Always remember to delete this extra byte before running your exploit on a process that is not being traced by gdb, for example the remote server, or this process will generate the exception and be killed!</p>

<h3 id="broken-shellcode">Broken shellcode</h3>

<p>The first thing to check when your shellcode (or ROP chain, what you want), is the integrity of your shellcode. Always remember that not all the input functions in <code class="language-plaintext highlighter-rouge">C</code> will forgive you like <code class="language-plaintext highlighter-rouge">read(fd, buf, size)</code>. Even the terrible <code class="language-plaintext highlighter-rouge">gets</code> will stop to receive your input at the first <code class="language-plaintext highlighter-rouge">0xa</code> byte found, namely <code class="language-plaintext highlighter-rouge">\n</code>. I always suggest to print your shellcode in a nice form and check that the corrupted memory of the program is exactly what you want before messing around with other possible problems.</p>

  </article>

</div>

            </main>
          </div>
        </div>

        <div class="row">
    <div class="col-lg-8 col-lg-offset-2">
        <footer>
            <div>
                <div class="footer left column one-half">
                    <small class="glow-yellow">
                        Theme <a href="https://github.com/gildasio/clyell"> clyell</a> by <a
                            href="https://github.com/gildasio/">gildasio</a> <br class="hidden visible-xs">powered by <a
                            href="https://github.com/jekyll/jekyll">{{ jekyll }}</a>
                    </small>
                </div>

                <div class="footer right column one-half">
                    <section class="small-font">
                        <a href="https://twitter.com/fibonhack"><span class="icon icon--twitter">
    <svg viewBox="0 0 16 16">
        <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
    </svg>
</span>
</a>
                        <a href="https://github.com/fibonhack"><span class="icon icon--github">
    <svg viewBox="0 0 16 16">
        <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
    </svg>
</span>
</a>
                    </section>
                </div>
            </div>
        </footer>
    </div>
</div>

      </div>
    </body>
</html>
